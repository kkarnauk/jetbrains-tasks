## Separator into Ranges

### Описание

Программа получает на вход отсортированный массив чисел, в котором каждое число встречается только один раз. 
Как результат, программа должна вернуть список диапазонов чисел, которые покрывают все числа в исходном массиве. 
Каждый элемент списка должен быть покрыт только одним диапазоном, при этом если числа нет в исходном списке, то его и не должно быть в любом из диапазонов.

Каждый диапазон `[x, y]` должен выглядеть как:
* `"x->y"` если `x != y`
* `"x"`, если `x == y`

### Примеры
* `input = [0, 1, 5, 9]`, `output =  ["0->1", "5", "9"]`
* `input = [0, 1, 2, 3, 5, 6, 7, 9]`, `output = ["0->3", "5->7", "9"]`

### Решение

Метод двух указателей. Будем поддерживать текущий указатель `i` на позицию в массиве. 
Заведем второй указатель `j = i` и будем постепенно увеличивать `j`, пока не закончился массив и выполняется `array[j + 1] - array[j] = 1`.
Добавим к ответу `Range(array[i], array[j])` и сделаем `i = j + 1`. Если `i` вышел за пределы массива, закончим.

Очевидно, что это работает за `O(n)`, потому что `i` и `j` только увеличиваются. 

Дополнительно для безопасности в начале проверяется, что массив действительно отсортирован и все элементы уникальны (иначе кидается исключение).

### Тесты

В классе `RangesSeparatorTest` реализованы тесты.
